[TOC]

# MySQL学习笔记

## 事务

数据库并发控制的基本单位，可以看做一系列SQL语句的集合

事务必须要么全部执行成功，要么全部执行失败（回滚）

例子：转账操作

### 事务的四个特性

**ACID**是事务的四个特性

原子性Atomicity：一个事务中所有操作全部完成或失败（回滚）

一致性Consistency:事务开始和结束之后数据完整性没有被破坏（转账的例子：转到钱没有凭空变多或消失）

拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

隔离性Isolation:允许多个事务同时对数据库修改和读写

持久性Durability：事务结束后，修改是永久不会丢失

### 事务并发的隔离性

**脏读（读取未提交的数据）**

A事务读取B事务**尚未提交**的数据，此时如果B事务发生错误并执行**回滚**操作，那么A事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于B事务更改了它，这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据，但事务B良心发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务A却什么都不知道，最终结果就是事务A读取了此次的脏数据，称为脏读。

这种情况常发生于转账与取款操作中

![zangdu](asset/zangdu.jpeg)

**不可重复读（前后多次读取，数据内容不一致）**

事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。
![norepeatread](asset/norepeatread.png)

**幻读（前后多次读取，数据总量不一致）**

事务A在执行读取操作，需要两次统计数据的**总量**，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。

![huandu](asset/huandu.png)

**不可重复读和幻读到底有什么区别呢？**

(1) 不可重复读是读取了其他事务更改的数据，**针对update操作**

解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

(2) 幻读是读取了其他事务新增的数据，**针对insert和delete操作**

解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。

**数据库的隔离级别**

数据库事务的隔离级别有4个，由低到高依次为

**读未提交**(Read uncommitted):别的事务可以读取到未提交的改变

**读已提交**(Read committed):别的事务只能读取到已经提交的改变

**可重复读**(Repeatable read): 同一个事务先后查询结果一样

**串行化**(Serializable) :事务完全串行化的执行，隔离级别最高，执行效率最低![gelijibie](asset/gelijibie.png)

MySQL 的默认隔离属性为Repeatable read  （可重复读）

## 乐观锁与悲观锁

**悲观锁**

悲观锁是先获取锁再进行操作。一锁二查三更新  select for update

```python
sqlalchemy: Address.query.filter_by(user_id=3).with_for_update().first()
```

**乐观锁**

乐观锁先修改，更新的时候发现数据已经变了就回滚（一般使用版本号和时间戳）

1. 乐观锁 适合查多改少，经常被并发修改的数据可能老是出现版本不一致导致有的线程操作常常失败。
2. 悲观锁 适合短事务（长事务导致其它事务一直被阻塞，影响系统性能），查少改多。



## InnoDB vs MyISAM

| 常见区别                                                     | MyISAM         | Innodb                                   |
| ------------------------------------------------------------ | -------------- | ---------------------------------------- |
| 事务                                                         | 不支持         | 支持                                     |
| 外键                                                         | 不支持         | 支持                                     |
| 锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的） | 只支持表级锁定 | 行级锁定、表级锁定，锁定力度小并发能力高 |
| 全文索引                                                     | 支持           | 不支持                                   |

## 问题

1.高并发写入数据库有数据重复

使用数据库的唯一索引    使用队列异步写入   使用redis等实现分布式锁





数据文字引用：

https://cloud.tencent.com/developer/article/1450773

https://coding.imooc.com/class/318.html